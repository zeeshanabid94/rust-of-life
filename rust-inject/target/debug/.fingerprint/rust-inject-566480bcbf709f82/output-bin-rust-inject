{"$message_type":"diagnostic","message":"only auto traits can be used as additional traits in a trait object","code":{"code":"E0225","explanation":"Multiple types were used as bounds for a closure or trait object.\n\nErroneous code example:\n\n```compile_fail,E0225\nfn main() {\n    let _: Box<dyn std::io::Read + std::io::Write>;\n}\n```\n\nRust does not currently support this.\n\nAuto traits such as Send and Sync are an exception to this rule:\nIt's possible to have bounds of one non-builtin trait, plus any number of\nauto traits. For example, the following compiles correctly:\n\n```\nfn main() {\n    let _: Box<dyn std::io::Read + Send + Sync>;\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":369,"byte_end":374,"line_start":20,"line_end":20,"column_start":66,"column_end":71,"is_primary":true,"text":[{"text":"    fn new(container: &mut Container) -> dyn Any + Send + Sync + Sized;","highlight_start":66,"highlight_end":71}],"label":"additional non-auto trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":349,"byte_end":352,"line_start":20,"line_end":20,"column_start":46,"column_end":49,"is_primary":false,"text":[{"text":"    fn new(container: &mut Container) -> dyn Any + Send + Sync + Sized;","highlight_start":46,"highlight_end":49}],"label":"first non-auto trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider creating a new trait with all of these as supertraits and using that trait here instead: `trait NewTrait: Any + Sized {}`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"auto-traits like `Send` and `Sync` are traits that have special properties; for more information on them, visit <https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0225]\u001b[0m\u001b[0m\u001b[1m: only auto traits can be used as additional traits in a trait object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:20:66\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn new(container: &mut Container) -> dyn Any + Send + Sync + Sized;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9madditional non-auto trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst non-auto trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider creating a new trait with all of these as supertraits and using that trait here instead: `trait NewTrait: Any + Sized {}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: auto-traits like `Send` and `Sync` are traits that have special properties; for more information on them, visit <https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits>\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"only auto traits can be used as additional traits in a trait object","code":{"code":"E0225","explanation":"Multiple types were used as bounds for a closure or trait object.\n\nErroneous code example:\n\n```compile_fail,E0225\nfn main() {\n    let _: Box<dyn std::io::Read + std::io::Write>;\n}\n```\n\nRust does not currently support this.\n\nAuto traits such as Send and Sync are an exception to this rule:\nIt's possible to have bounds of one non-builtin trait, plus any number of\nauto traits. For example, the following compiles correctly:\n\n```\nfn main() {\n    let _: Box<dyn std::io::Read + Send + Sync>;\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1936,"byte_end":1941,"line_start":87,"line_end":87,"column_start":58,"column_end":63,"is_primary":true,"text":[{"text":"    fn new(c: &mut Container) -> dyn Any + Send + Sync + Sized {","highlight_start":58,"highlight_end":63}],"label":"additional non-auto trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1916,"byte_end":1919,"line_start":87,"line_end":87,"column_start":38,"column_end":41,"is_primary":false,"text":[{"text":"    fn new(c: &mut Container) -> dyn Any + Send + Sync + Sized {","highlight_start":38,"highlight_end":41}],"label":"first non-auto trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider creating a new trait with all of these as supertraits and using that trait here instead: `trait NewTrait: Any + Sized {}`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"auto-traits like `Send` and `Sync` are traits that have special properties; for more information on them, visit <https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits>","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0225]\u001b[0m\u001b[0m\u001b[1m: only auto traits can be used as additional traits in a trait object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:87:58\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn new(c: &mut Container) -> dyn Any + Send + Sync + Sized {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9madditional non-auto trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst non-auto trait\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: consider creating a new trait with all of these as supertraits and using that trait here instead: `trait NewTrait: Any + Sized {}`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: auto-traits like `Send` and `Sync` are traits that have special properties; for more information on them, visit <https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits>\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the size for values of type `dyn Any + Send + Sync` cannot be known at compilation time","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1403,"byte_end":1430,"line_start":61,"line_end":61,"column_start":48,"column_end":75,"is_primary":true,"text":[{"text":"        let new = Arc::new(Mutex::new(Box::new(<S as Singleton>::new(self))));","highlight_start":48,"highlight_end":75}],"label":"doesn't have a size known at compile-time","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1394,"byte_end":1402,"line_start":61,"line_end":61,"column_start":39,"column_end":47,"is_primary":false,"text":[{"text":"        let new = Arc::new(Mutex::new(Box::new(<S as Singleton>::new(self))));","highlight_start":39,"highlight_end":47}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Sized` is not implemented for `dyn Any + Send + Sync`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `Box::<T>::new`","code":null,"level":"note","spans":[{"file_name":"/home/zeeshan/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs","byte_start":7886,"byte_end":7889,"line_start":217,"line_end":217,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"    pub fn new(x: T) -> Self {","highlight_start":12,"highlight_end":15}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/zeeshan/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs","byte_start":7468,"byte_end":7469,"line_start":202,"line_end":202,"column_start":6,"column_end":7,"is_primary":true,"text":[{"text":"impl<T> Box<T> {","highlight_start":6,"highlight_end":7}],"label":"required by this bound in `Box::<T>::new`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the size for values of type `dyn Any + Send + Sync` cannot be known at compilation time\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:61:48\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let new = Arc::new(Mutex::new(Box::new(<S as Singleton>::new(self))));\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdoesn't have a size known at compile-time\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound introduced by this call\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `Sized` is not implemented for `dyn Any + Send + Sync`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `Box::<T>::new`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zeeshan/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:202:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m202\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl<T> Box<T> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `Box::<T>::new`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m217\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new(x: T) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrequired by a bound in this associated function\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1490,"byte_end":1493,"line_start":62,"line_end":62,"column_start":56,"column_end":59,"is_primary":true,"text":[{"text":"        self.singletons.insert(<S as Singleton>::id(), new);","highlight_start":56,"highlight_end":59}],"label":"expected trait `Any + Send + Sync`, found a different trait `Any + Send + Sync`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1459,"byte_end":1465,"line_start":62,"line_end":62,"column_start":25,"column_end":31,"is_primary":false,"text":[{"text":"        self.singletons.insert(<S as Singleton>::id(), new);","highlight_start":25,"highlight_end":31}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Arc<Mutex<Box<(dyn Any + Send + Sync + 'static)>>>`\n   found struct `Arc<Mutex<Box<dyn Any + Send + Sync>>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the return type of this call is `Arc<Mutex<Box<dyn Any + Send + Sync>>>` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1490,"byte_end":1493,"line_start":62,"line_end":62,"column_start":56,"column_end":59,"is_primary":false,"text":[{"text":"        self.singletons.insert(<S as Singleton>::id(), new);","highlight_start":56,"highlight_end":59}],"label":"this argument influences the return type of `insert`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":1443,"byte_end":1494,"line_start":62,"line_end":62,"column_start":9,"column_end":60,"is_primary":true,"text":[{"text":"        self.singletons.insert(<S as Singleton>::id(), new);","highlight_start":9,"highlight_end":60}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/home/zeeshan/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs","byte_start":35787,"byte_end":35793,"line_start":1105,"line_end":1105,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"    pub fn insert(&mut self, k: K, v: V) -> Option<V> {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:62:56\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        self.singletons.insert(<S as Singleton>::id(), new);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected trait `Any + Send + Sync`, found a different trait `Any + Send + Sync`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this method are incorrect\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `Arc<Mutex<Box<\u001b[0m\u001b[0m\u001b[1m\u001b[35m(dyn Any + Send + Sync + 'static)\u001b[0m\u001b[0m>>>`\u001b[0m\n\u001b[0m                found struct `Arc<Mutex<Box<\u001b[0m\u001b[0m\u001b[1m\u001b[35mdyn Any + Send + Sync\u001b[0m\u001b[0m>>>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: the return type of this call is `Arc<Mutex<Box<dyn Any + Send + Sync>>>` due to the type of the argument passed\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:62:9\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        self.singletons.insert(<S as Singleton>::id(), new);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis argument influences the return type of `insert`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: method defined here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/home/zeeshan/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:1105:12\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1105\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"return type cannot have an unboxed trait object","code":{"code":"E0746","explanation":"An unboxed trait object was used as a return value.\n\nErroneous code example:\n\n```compile_fail,E0746\ntrait T {\n    fn bar(&self);\n}\nstruct S(usize);\nimpl T for S {\n    fn bar(&self) {}\n}\n\n// Having the trait `T` as return type is invalid because\n// unboxed trait objects do not have a statically known size:\nfn foo() -> dyn T { // error!\n    S(42)\n}\n```\n\nReturn types cannot be `dyn Trait`s as they must be `Sized`.\n\nTo avoid the error there are a couple of options.\n\nIf there is a single type involved, you can use [`impl Trait`]:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n// The compiler will select `S(usize)` as the materialized return type of this\n// function, but callers will only know that the return type implements `T`.\nfn foo() -> impl T { // ok!\n    S(42)\n}\n```\n\nIf there are multiple types involved, the only way you care to interact with\nthem is through the trait's interface, and having to rely on dynamic dispatch\nis acceptable, then you can use [trait objects] with `Box`, or other container\ntypes like `Rc` or `Arc`:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\nstruct O(&'static str);\nimpl T for O {\n    fn bar(&self) {}\n}\n\n// This now returns a \"trait object\" and callers are only be able to access\n// associated items from `T`.\nfn foo(x: bool) -> Box<dyn T> { // ok!\n    if x {\n        Box::new(S(42))\n    } else {\n        Box::new(O(\"val\"))\n    }\n}\n```\n\nFinally, if you wish to still be able to access the original type, you can\ncreate a new `enum` with a variant for each type:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n# struct O(&'static str);\n# impl T for O {\n#     fn bar(&self) {}\n# }\nenum E {\n    S(S),\n    O(O),\n}\n\n// The caller can access the original types directly, but it needs to match on\n// the returned `enum E`.\nfn foo(x: bool) -> E {\n    if x {\n        E::S(S(42))\n    } else {\n        E::O(O(\"val\"))\n    }\n}\n```\n\nYou can even implement the `trait` on the returned `enum` so the callers\n*don't* have to match on the returned value to invoke the associated items:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n# struct O(&'static str);\n# impl T for O {\n#     fn bar(&self) {}\n# }\n# enum E {\n#     S(S),\n#     O(O),\n# }\nimpl T for E {\n    fn bar(&self) {\n        match self {\n            E::S(s) => s.bar(),\n            E::O(o) => o.bar(),\n        }\n    }\n}\n```\n\nIf you decide to use trait objects, be aware that these rely on\n[dynamic dispatch], which has performance implications, as the compiler needs\nto emit code that will figure out which method to call *at runtime* instead of\nduring compilation. Using trait objects we are trading flexibility for\nperformance.\n\n[`impl Trait`]: https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits\n[trait objects]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\n[dynamic dispatch]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1912,"byte_end":1941,"line_start":87,"line_end":87,"column_start":34,"column_end":63,"is_primary":true,"text":[{"text":"    fn new(c: &mut Container) -> dyn Any + Send + Sync + Sized {","highlight_start":34,"highlight_end":63}],"label":"doesn't have a size known at compile-time","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1912,"byte_end":1916,"line_start":87,"line_end":87,"column_start":34,"column_end":38,"is_primary":true,"text":[{"text":"    fn new(c: &mut Container) -> dyn Any + Send + Sync + Sized {","highlight_start":34,"highlight_end":38}],"label":null,"suggested_replacement":"impl ","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"box the return type, and wrap all of the returned values in `Box::new`","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1912,"byte_end":1912,"line_start":87,"line_end":87,"column_start":34,"column_end":34,"is_primary":true,"text":[{"text":"    fn new(c: &mut Container) -> dyn Any + Send + Sync + Sized {","highlight_start":34,"highlight_end":34}],"label":null,"suggested_replacement":"Box<","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":1941,"byte_end":1941,"line_start":87,"line_end":87,"column_start":63,"column_end":63,"is_primary":true,"text":[{"text":"    fn new(c: &mut Container) -> dyn Any + Send + Sync + Sized {","highlight_start":63,"highlight_end":63}],"label":null,"suggested_replacement":">","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":1952,"byte_end":1952,"line_start":88,"line_end":88,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"        C(1)","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"Box::new(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/main.rs","byte_start":1956,"byte_end":1956,"line_start":88,"line_end":88,"column_start":13,"column_end":13,"is_primary":true,"text":[{"text":"        C(1)","highlight_start":13,"highlight_end":13}],"label":null,"suggested_replacement":")","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0746]\u001b[0m\u001b[0m\u001b[1m: return type cannot have an unboxed trait object\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:87:34\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn new(c: &mut Container) -> dyn Any + Send + Sync + Sized {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdoesn't have a size known at compile-time\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: return an `impl Trait` instead of a `dyn Trait`, if all returned values are the same type\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    fn new(c: &mut Container) -> \u001b[0m\u001b[0m\u001b[38;5;10mimpl \u001b[0m\u001b[0mAny + Send + Sync + Sized {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[38;5;10m~~~~\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: box the return type, and wrap all of the returned values in `Box::new`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m87\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m    fn new(c: &mut Container) -> \u001b[0m\u001b[0m\u001b[38;5;10mBox<\u001b[0m\u001b[0mdyn Any + Send + Sync + Sized\u001b[0m\u001b[0m\u001b[38;5;10m>\u001b[0m\u001b[0m {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m88\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10mBox::new(\u001b[0m\u001b[0mC(1)\u001b[0m\u001b[0m\u001b[38;5;10m)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `0` on type `Arc<Mutex<C>>`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2049,"byte_end":2050,"line_start":94,"line_end":94,"column_start":53,"column_end":54,"is_primary":true,"text":[{"text":"        println!(\"output: {}, {}\", self.0.0, self.1.0)","highlight_start":53,"highlight_end":54}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0609]\u001b[0m\u001b[0m\u001b[1m: no field `0` on type `Arc<Mutex<C>>`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:94:53\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m94\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        println!(\"output: {}, {}\", self.0.0, self.1.0)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munknown field\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2448,"byte_end":2458,"line_start":112,"line_end":112,"column_start":23,"column_end":33,"is_primary":true,"text":[{"text":"        B(a_instance, c_instance)","highlight_start":23,"highlight_end":33}],"label":"expected `Arc<Mutex<C>>`, found `Arc<Mutex<...>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":2434,"byte_end":2435,"line_start":112,"line_end":112,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        B(a_instance, c_instance)","highlight_start":9,"highlight_end":10}],"label":"arguments to this struct are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Arc<Mutex<C>>`\n   found struct `Arc<Mutex<(dyn Any + Send + Sync + 'static)>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`C` implements `Any` so you could change the expected type to `Box<dyn Any>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"tuple struct defined here","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":1630,"byte_end":1631,"line_start":71,"line_end":71,"column_start":12,"column_end":13,"is_primary":true,"text":[{"text":"pub struct B(A, Arc<Mutex<C>>);","highlight_start":12,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:112:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m112\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        B(a_instance, c_instance)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Arc<Mutex<C>>`, found `Arc<Mutex<...>>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this struct are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected struct `Arc<Mutex<\u001b[0m\u001b[0m\u001b[1m\u001b[35mC\u001b[0m\u001b[0m>>`\u001b[0m\n\u001b[0m               found struct `Arc<Mutex<\u001b[0m\u001b[0m\u001b[1m\u001b[35m(dyn Any + Send + Sync + 'static)\u001b[0m\u001b[0m>>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: `C` implements `Any` so you could change the expected type to `Box<dyn Any>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: tuple struct defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:71:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m71\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct B(A, Arc<Mutex<C>>);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `c`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":1701,"byte_end":1702,"line_start":76,"line_end":76,"column_start":12,"column_end":13,"is_primary":true,"text":[{"text":"    fn new(c: &mut Container) -> Self {","highlight_start":12,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":1701,"byte_end":1702,"line_start":76,"line_end":76,"column_start":12,"column_end":13,"is_primary":true,"text":[{"text":"    fn new(c: &mut Container) -> Self {","highlight_start":12,"highlight_end":13}],"label":null,"suggested_replacement":"_c","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `c`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:76:12\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn new(c: &mut Container) -> Self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_c`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_variables)]` on by default\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `container`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":2172,"byte_end":2181,"line_start":103,"line_end":103,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    fn new(container: &mut Container) -> Self {","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":2172,"byte_end":2181,"line_start":103,"line_end":103,"column_start":12,"column_end":21,"is_primary":true,"text":[{"text":"    fn new(container: &mut Container) -> Self {","highlight_start":12,"highlight_end":21}],"label":null,"suggested_replacement":"_container","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `container`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:103:12\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn new(container: &mut Container) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_container`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 7 previous errors; 2 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 7 previous errors; 2 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0225, E0277, E0308, E0609, E0746.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0225, E0277, E0308, E0609, E0746.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0225`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0225`.\u001b[0m\n"}
